# ログイン機能のSQLインジェクション

## 脆弱性の説明
ログイン処理でユーザー入力を直接SQLクエリに結合しているため、SQLインジェクションが可能です。

## 影響範囲
- ユーザー認証のバイパス
- データベース情報の漏洩
- 不正なアカウントアクセス

## 攻撃方法と手順

### 1. 認証バイパス攻撃

1. アプリケーションのログイン画面にアクセスします
2. ユーザーIDフィールドに以下のSQLインジェクションペイロードを入力します：
   ログイン状態にさせる
   ```
   ' OR '1'='1' -- 
   ```
   または、以下のように既存のユーザー名を使用してログイン状態にさせる
   ```
   alice' -- 
   ```
3. パスワードフィールドには任意の値（例：`xxx`）を入力します
4. ログインボタンをクリックします

このペイロードは、WHERE句の条件を常に真にするため、データベース内の最初のユーザー（多くの場合は管理者）としてログインできます。

### 2. データベース情報の取得攻撃

1. アプリケーションのログイン画面にアクセスします
2. ユーザーIDフィールドに以下のSQLインジェクションペイロードを入力します：
   ```
   ' UNION SELECT table_name, column_name FROM information_schema.columns WHERE table_schema = DATABASE() -- 
   ```
3. パスワードフィールドには任意の値を入力します
4. ログインボタンをクリックします
このペイロードは、データベースのスキーマ情報を取得しようとします。エラーメッセージが表示される場合は、そのエラーメッセージからデータベース構造に関する情報が漏洩している可能性があります。

## 攻撃成功の確認手順

### 1. 認証バイパスの確認

1. 上記のペイロードを使用してログインを試みます
2. ログイン後、ダッシュボードやプロフィールページなど、認証が必要なページにアクセスできることを確認します
3. ページ上にユーザー名やプロフィール情報が表示されていることを確認します

### 2. データベース情報の取得の確認

1. 上記のペイロードを使用してログインを試みます
2. ログイン後、プロフィールページにアクセスします
3. ニックネームにテーブルのカラム名、ユーザIDに@テーブル名が表示されていることを確認します

## 対策方法
### 1. プリペアドステートメントの使用
```go
// 修正前（脆弱なコード）
query := fmt.Sprintf("SELECT id, nickname FROM users WHERE id = '%s' AND password = SHA2('%s', 256)", 
    credentials.ID, credentials.Password)

// 修正後（安全なコード）
query := "SELECT id, nickname FROM users WHERE id = ? AND password = SHA2(?, 256)"
err := db.QueryRow(query, credentials.ID, credentials.Password).Scan(&user.ID, &user.Nickname)
```

プリペアドステートメント（Prepared Statement）は、SQLクエリの実行を2段階に分けるデータベースの機能です。

1. 準備段階: SQLクエリのテンプレートをデータベースに送信し、解析・コンパイルします
2. 実行段階: パラメータ値を別途送信し、準備済みのクエリを実行します

ユーザー入力は常にデータとして扱われ、決してSQLとして解釈されません。

**プリペアドステートメントのメリット**
- セキュリティの向上
    - SQLコードとユーザーデータを完全に分離することができる
    - データベースエンジンレベルで保護
    - データ型に応じた適切なエスケープ処理
    - 型の安全性を確保
- パフォーマンスの向上
    - コンパイル済みのクエリを再利用できる
    - パラメータ値のエスケープ処理が不要

